<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Prasanth Janardhanan</title>
    <link>/tags/go/</link>
    <description>Recent content in go on Prasanth Janardhanan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Prasanth Janardhanan</copyright>
    <lastBuildDate>Wed, 15 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lock-Free Data Structures and Wait-Free Algorithms in Go: From Theory to Practice</title>
      <link>/go/lock-free-data-structures/</link>
      <pubDate>Wed, 15 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>/go/lock-free-data-structures/</guid>
      <description>Have you ever been stuck in a bank line where everyone needs to visit the same teller? Frustrating, right? Now imagine a bank where every customer could magically make their transaction without waiting for others to finish. Sounds like a dream? Well, that&amp;rsquo;s exactly what lock-free and wait-free programming aims to achieve in the world of concurrent computing!
The Concurrent Programming Challenge Let&amp;rsquo;s start with a simple scenario. Imagine you and your roommate share a kitchen (our computer&amp;rsquo;s memory), and you&amp;rsquo;re both trying to make sandwiches (execute operations) at the same time.</description>
    </item>
    
    <item>
      <title>Model Context Protocol (MCP): Lets Implement an MCP server in Go</title>
      <link>/ai/mcp-go/</link>
      <pubDate>Thu, 02 Jan 2025 09:55:45 +0000</pubDate>
      
      <guid>/ai/mcp-go/</guid>
      <description>Model Context Protocol (MCP) is rapidly transforming how we interact with computers by enabling natural language instructions to handle complex tasks. As we stand at the beginning of this revolution, we&amp;rsquo;re witnessing fast-paced development in MCP tools and components.
While a detailed introduction to MCP was covered in our previous post, here&amp;rsquo;s a quick refresher: MCP servers expose various capabilities (like resources, tools, and prompts) to clients. The clients can then use these capabilities in conjunction with Large Language Models (LLMs) to perform tasks.</description>
    </item>
    
    <item>
      <title>Building a Reliable ETL System with Go and Temporal: When Data Needs to Move Like a Marvel Superhero ü¶∏‚Äç‚ôÇÔ∏è</title>
      <link>/microservices/etl-go-temporal/</link>
      <pubDate>Thu, 28 Nov 2024 00:00:00 +0000</pubDate>
      
      <guid>/microservices/etl-go-temporal/</guid>
      <description>Ever tried moving your entire apartment through a drinking straw? That&amp;rsquo;s basically what building ETL (Extract, Transform, Load) systems feels like sometimes. You&amp;rsquo;ve got terabytes of data that need to go from Point A to Point B, transform from one shape to another along the way, and arrive without losing a single byte. Oh, and it needs to happen yesterday.
As a backend engineer who&amp;rsquo;s battled these challenges at scale, I&amp;rsquo;ve learned that building reliable ETL systems is less about writing perfect code (though that helps) and more about preparing for everything that could possibly go wrong.</description>
    </item>
    
    <item>
      <title>Building a simple query parser using PEG in Go</title>
      <link>/go/peg-parser-in-go/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/go/peg-parser-in-go/</guid>
      <description>In another post, Simple Query Parser we had built a simple query parser using Participle - a parser builder for go lang. Parsing expression grammar (PEG) is a type of grammar. The advantage of PEG is that it doesn&amp;rsquo;t tolerate ambiguous grammar definitions and so is better in error reporting.
The go language port of PEG is pigeon The popular Javascript port of PEG is pegjs. A good introduction to PEG grammar can be found in the pegjs documentation and also here.</description>
    </item>
    
    <item>
      <title>Let&#39;s build a search query parser in Go</title>
      <link>/go/simple-query-parser/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/go/simple-query-parser/</guid>
      <description>Mini languages are great. Makes it easy to express what you want in a concise manner. Sometimes a complex UI can be replaced with a mini-language. Some time back, google used to support a simple language in the search queries. For example: &amp;ldquo;some phrase&amp;rdquo; +required -not_required . Alas! they stopped it and Google search is less cool ever since. I would count regular expressions also as a mini-language.
Imagine we are building an online store that allows searching for products using a simple but structured query language.</description>
    </item>
    
  </channel>
</rss>
