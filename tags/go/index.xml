<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Prasanth Janardhanan</title>
    <link>/tags/go/</link>
    <description>Recent content in Go on Prasanth Janardhanan</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Prasanth Janardhanan</copyright>
    <lastBuildDate>Wed, 15 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lock-Free Data Structures and Wait-Free Algorithms in Go: From Theory to Practice</title>
      <link>/go/lock-free-data-structures/</link>
      <pubDate>Wed, 15 Jan 2025 00:00:00 +0000</pubDate>
      <guid>/go/lock-free-data-structures/</guid>
      <description>&lt;p&gt;Have you ever been stuck in a bank line where everyone needs to visit the same teller? Frustrating, right? Now imagine a bank where every customer could magically make their transaction without waiting for others to finish. Sounds like a dream? Well, that&amp;rsquo;s exactly what lock-free and wait-free programming aims to achieve in the world of concurrent computing!&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-concurrent-programming-challenge&#34;&gt;The Concurrent Programming Challenge&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with a simple scenario. Imagine you and your roommate share a kitchen (our computer&amp;rsquo;s memory), and you&amp;rsquo;re both trying to make sandwiches (execute operations) at the same time. In traditional programming, we&amp;rsquo;d put a lock on the kitchen ‚Äì &amp;ldquo;Hey, I&amp;rsquo;m using the kitchen, wait your turn!&amp;rdquo; But what if your roommate just needs to grab a glass of water? Should they really have to wait for your entire sandwich-making process to finish?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Model Context Protocol (MCP): Lets Implement an MCP server in Go</title>
      <link>/ai/mcp-go/</link>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <guid>/ai/mcp-go/</guid>
      <description>&lt;p&gt;Model Context Protocol (MCP) is rapidly transforming how we interact with computers by enabling natural language instructions to handle complex tasks. As we stand at the beginning of this revolution, we&amp;rsquo;re witnessing fast-paced development in MCP tools and components.&lt;/p&gt;&#xA;&lt;p&gt;While a detailed introduction to MCP was covered in our previous post, here&amp;rsquo;s a quick refresher: MCP  servers expose various capabilities (like resources, tools, and prompts) to clients. The clients can then use these capabilities in conjunction with Large Language Models (LLMs) to perform tasks. The protocol standardizes how these components communicate, making it easy to build interoperable AI-powered applications.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building a Reliable ETL System with Go and Temporal: When Data Needs to Move Like a Marvel Superhero ü¶∏‚Äç‚ôÇÔ∏è</title>
      <link>/microservices/etl-go-temporal/</link>
      <pubDate>Thu, 28 Nov 2024 00:00:00 +0000</pubDate>
      <guid>/microservices/etl-go-temporal/</guid>
      <description>&lt;p&gt;Ever tried moving your entire apartment through a drinking straw? That&amp;rsquo;s basically what building ETL (Extract, Transform, Load) systems feels like sometimes. You&amp;rsquo;ve got terabytes of data that need to go from Point A to Point B, transform from one shape to another along the way, and arrive without losing a single byte. Oh, and it needs to happen yesterday.&lt;/p&gt;&#xA;&lt;p&gt;As a backend engineer who&amp;rsquo;s battled these challenges at scale, I&amp;rsquo;ve learned that building reliable ETL systems is less about writing perfect code (though that helps) and more about preparing for everything that could possibly go wrong. Because trust me, Murphy&amp;rsquo;s Law isn&amp;rsquo;t just a suggestion when it comes to data pipelines ‚Äì it&amp;rsquo;s more like a promise.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building a simple query parser using PEG in Go</title>
      <link>/go/peg-parser-in-go/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/go/peg-parser-in-go/</guid>
      <description>&lt;p&gt;In another post, &lt;a href=&#34;../simple-query-parser/&#34;&gt;Simple Query Parser&lt;/a&gt; we had built a simple query parser using &lt;a href=&#34;https://github.com/alecthomas/participle&#34;&gt;Participle&lt;/a&gt; - a parser builder for go lang.&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Parsing_expression_grammar&#34;&gt;Parsing expression grammar (PEG)&lt;/a&gt; is a type of grammar. The advantage of PEG is that it doesn&amp;rsquo;t tolerate ambiguous grammar definitions and so is better in error reporting.&lt;/p&gt;&#xA;&lt;p&gt;The go language port of PEG is &lt;a href=&#34;https://pkg.go.dev/github.com/mna/pigeon&#34;&gt;pigeon&lt;/a&gt;&#xA;The popular Javascript port of PEG is &lt;a href=&#34;https://pegjs.org/documentation&#34;&gt;pegjs&lt;/a&gt;. A good introduction to PEG grammar can be found in the &lt;a href=&#34;https://pegjs.org/documentation&#34;&gt;pegjs documentation&lt;/a&gt; and also &lt;a href=&#34;https://github.com/PhilippeSigaud/Pegged/wiki/PEG-Basics&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Let&#39;s build a search query parser in Go</title>
      <link>/go/simple-query-parser/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/go/simple-query-parser/</guid>
      <description>&lt;p&gt;Mini languages are great. Makes it easy to express what you want in a concise manner. Sometimes a complex UI can be replaced with a mini-language. Some time back, google used to support a simple language in the search queries. For example: &amp;ldquo;some phrase&amp;rdquo; +required -not_required . Alas! they stopped it and Google search is less cool ever since. I would count regular expressions also as a mini-language.&lt;/p&gt;&#xA;&lt;p&gt;Imagine we are building an online store that allows searching for products using a simple but structured query language. You can search for a laptop with more than 8GB RAM and more than 512GB SSD using this query:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
