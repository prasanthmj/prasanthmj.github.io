<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Lock-Free Data Structures and Wait-Free Algorithms in Go: From Theory to Practice </title><meta name="keywords" content="go, data structures" /><meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/css/styles.css" />
</head>
<body class="antialiased text-grey-900">
    
    <div class="container mx-auto max-w-screen-lg">
    <header class="flex items-center justify-between h-16 px-3 border-b border-gray-300">
    <div >
        <a href="/" class="flex items-center">
            <span class="text-lg text-gray-800 font-semibold">Prasanth Janardhanan</span>
        </a>
    </div>
    <div>
        <ul class="flex">
            <li class="t ml-5 text-md text-gray-700 hover:text-red-800"><a href="/" class="hover:underline">Articles</a></li>
            <li class="t ml-5 text-md text-gray-700 hover:text-red-800"><a href="/projects/" class="hover:underline">Projects</a></li>
            <li class="t ml-5 text-md text-gray-700 hover:text-red-800"><a href="/about/" class="hover:underline">About</a></li>
        </ul>
    </div>
</header>
    
    <article class="mt-6 mx-auto md:w-9/12 min-h-screen">
<h1 class="mt-5">Lock-Free Data Structures and Wait-Free Algorithms in Go: From Theory to Practice</h1>
<ul class="flex mb-2 list-none px-0 text-sm mt-0 ml-0 pt-0">
    
      <li class="pr-4 list-none">&#x1f3f7; <a href="/tags/go" class="text-gray-600">go</a> </li>
    
      <li class="pr-4 list-none">&#x1f3f7; <a href="/tags/data-structures" class="text-gray-600">data structures</a> </li>
    
</ul>
  
<p>Have you ever been stuck in a bank line where everyone needs to visit the same teller? Frustrating, right? Now imagine a bank where every customer could magically make their transaction without waiting for others to finish. Sounds like a dream? Well, that&rsquo;s exactly what lock-free and wait-free programming aims to achieve in the world of concurrent computing!</p>
<h2 id="the-concurrent-programming-challenge">The Concurrent Programming Challenge</h2>
<p>Let&rsquo;s start with a simple scenario. Imagine you and your roommate share a kitchen (our computer&rsquo;s memory), and you&rsquo;re both trying to make sandwiches (execute operations) at the same time. In traditional programming, we&rsquo;d put a lock on the kitchen – &ldquo;Hey, I&rsquo;m using the kitchen, wait your turn!&rdquo; But what if your roommate just needs to grab a glass of water? Should they really have to wait for your entire sandwich-making process to finish?</p>
<p>This is exactly the problem with traditional locking mechanisms in programming. They&rsquo;re like putting a &ldquo;Do Not Enter&rdquo; sign on an entire room when you might only need to protect a single drawer.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Traditional locking approach
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> counter <span style="color:#458;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> mutex sync.Mutex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">incrementCounter</span>() {
</span></span><span style="display:flex;"><span>    mutex.<span style="color:#900;font-weight:bold">Lock</span>()
</span></span><span style="display:flex;"><span>    counter<span style="color:#000;font-weight:bold">++</span>
</span></span><span style="display:flex;"><span>    mutex.<span style="color:#900;font-weight:bold">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code is like saying, &ldquo;Nobody else can even LOOK at the counter while I&rsquo;m updating it!&rdquo; A bit extreme, don&rsquo;t you think?</p>
<h2 id="why-traditional-locks-fall-short">Why Traditional Locks Fall Short</h2>
<p>Traditional locks come with some serious baggage:</p>
<ol>
<li>
<p><strong>Priority Inversion</strong>: Imagine you&rsquo;re a VIP (high-priority task) waiting to use the kitchen, but a slow cook (low-priority task) has locked it. Now you&rsquo;re stuck waiting! In computing terms, this can cause critical tasks to wait for less important ones.</p>
</li>
<li>
<p><strong>Deadlocks</strong>: Picture two people, each holding one key to two different locks, each waiting for the other person&rsquo;s key. They&rsquo;ll be waiting forever! This is a deadlock, and it&rsquo;s more common than you might think:</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Potential deadlock scenario
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">dangerousOperation</span>() {
</span></span><span style="display:flex;"><span>    mutex1.<span style="color:#900;font-weight:bold">Lock</span>()
</span></span><span style="display:flex;"><span>    mutex2.<span style="color:#900;font-weight:bold">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// If another goroutine locks these in opposite order...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// ...we have a deadlock!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    mutex2.<span style="color:#900;font-weight:bold">Unlock</span>()
</span></span><span style="display:flex;"><span>    mutex1.<span style="color:#900;font-weight:bold">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li><strong>Convoying</strong>: Think of a slow shopper at the grocery checkout. Even though other shoppers might have quick purchases, everyone gets stuck behind the slow one. This is convoying, and it&rsquo;s a real performance killer.</li>
</ol>
<h2 id="the-promise-of-lock-free-and-wait-free-programming">The Promise of Lock-Free and Wait-Free Programming</h2>
<p>This is where lock-free and wait-free programming enters the scene. Instead of putting locks on our data structures, we design them to be safely accessed by multiple threads simultaneously – like having a kitchen where multiple cooks can work without stepping on each other&rsquo;s toes.</p>
<p>Here&rsquo;s a simple example of a lock-free counter in Go:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> <span style="color:#d14">&#34;sync/atomic&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> counter <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">incrementCounter</span>() {
</span></span><span style="display:flex;"><span>    atomic.<span style="color:#900;font-weight:bold">AddUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>counter, <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code is like having a magical counter that multiple people can update simultaneously without any conflicts. No locks, no waiting, just smooth concurrent operations!</p>
<h2 id="the-building-blocks-of-concurrent-programming">The Building Blocks of Concurrent Programming</h2>
<p>Imagine you&rsquo;re in a shared kitchen again, but this time it&rsquo;s a busy restaurant kitchen. Multiple chefs are working simultaneously, each preparing different dishes. How do they coordinate without chaos? This is the essence of concurrent programming.</p>
<h3 id="memory-our-shared-kitchen-space">Memory: Our Shared Kitchen Space</h3>
<p>In a computer, memory is like our kitchen&rsquo;s counter space. But here&rsquo;s the tricky part – modern computers don&rsquo;t just have one counter. They have multiple levels of storage (caches) that act like different prep stations in our kitchen.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> sharedIngredient <span style="color:#458;font-weight:bold">int</span>  <span style="color:#998;font-style:italic">// This is like a shared ingredient on the counter
</span></span></span></code></pre></div><p>Just like a chef might work with their own copy of ingredients at their station before combining them with others, modern CPUs often work with their own cached copies of data:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// What CPU1 sees
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>sharedIngredient = <span style="color:#099">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// What CPU2 sees (might be different!)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>sharedIngredient = <span style="color:#099">3</span>
</span></span></code></pre></div><h2 id="memory-ordering-when-things-get-wild">Memory Ordering: When Things Get Wild</h2>
<p>Here&rsquo;s where it gets interesting. Imagine you&rsquo;re giving instructions to two chefs:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> flour = <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> sugar = <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Chef 1&#39;s instructions
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>flour = <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>sugar = <span style="color:#099">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Chef 2&#39;s instructions
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">if</span> sugar <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">2</span> {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#900;font-weight:bold">Println</span>(flour)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You might expect that if Chef 2 sees <code>sugar = 2</code>, they&rsquo;ll definitely see <code>flour = 1</code>. But in the world of modern computers, this isn&rsquo;t guaranteed! It&rsquo;s like having overeager chefs who might rearrange their tasks for &ldquo;efficiency.&rdquo; This is called memory reordering.</p>
<h2 id="atomic-operations-the-perfect-dance-move">Atomic Operations: The Perfect Dance Move</h2>
<p>Enter atomic operations – they&rsquo;re like perfectly choreographed dance moves that can&rsquo;t be interrupted. Take our earlier counter example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> <span style="color:#d14">&#34;sync/atomic&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> counter <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// This is like a perfect, uninterruptible dance move
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>atomic.<span style="color:#900;font-weight:bold">AddUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>counter, <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Instead of this clumsy two-step that could go wrong
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// temp := counter
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// counter = temp + 1
</span></span></span></code></pre></div><p>Think of atomic operations like those amazing street performers who can spin plates – once they start a move, they complete it perfectly every time, no matter what&rsquo;s happening around them.</p>
<h2 id="compare-and-swap-the-heart-of-lock-free-programming">Compare-and-Swap: The Heart of Lock-Free Programming</h2>
<p>Now we&rsquo;re getting to the good stuff! Compare-and-Swap is like a magical kitchen helper who can:</p>
<ol>
<li>Look at a value</li>
<li>Compare it to what they expect</li>
<li>Change it only if it matches their expectation</li>
</ol>
<p>All in one uninterruptible motion!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> value <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">incrementWithCAS</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        current <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>value)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>value, current, current<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If we&#39;re here, someone else modified the value - try again!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is like saying: &ldquo;If the bowl has exactly 3 eggs, add one more. If not, check again!&rdquo; It&rsquo;s our first real taste of lock-free programming!</p>
<h2 id="the-happens-before-relationship-establishing-order-in-chaos">The Happens-Before Relationship: Establishing Order in Chaos</h2>
<p>In our kitchen analogy, &ldquo;happens-before&rdquo; is like saying, &ldquo;You MUST crack the eggs BEFORE making the omelet.&rdquo; In Go, we have similar rules:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> data <span style="color:#458;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> ready <span style="color:#458;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Writer goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">write</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Prepare the data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    d <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">prepareData</span>()
</span></span><span style="display:flex;"><span>    atomic.<span style="color:#900;font-weight:bold">StoreInt32</span>(<span style="color:#000;font-weight:bold">&amp;</span>data, d)
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Signal that data is ready
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    atomic.<span style="color:#900;font-weight:bold">StoreInt32</span>(<span style="color:#000;font-weight:bold">&amp;</span>ready, <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Reader goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">read</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Check if data is ready
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> atomic.<span style="color:#900;font-weight:bold">LoadInt32</span>(<span style="color:#000;font-weight:bold">&amp;</span>ready) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
</span></span><span style="display:flex;"><span>        runtime.<span style="color:#900;font-weight:bold">Gosched</span>() <span style="color:#998;font-style:italic">// Be nice to other goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// At this point, we&#39;re guaranteed to see the prepared data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    value <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadInt32</span>(<span style="color:#000;font-weight:bold">&amp;</span>data)
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#900;font-weight:bold">Println</span>(value)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The atomic operations create a happens-before relationship, ensuring that if the reader sees <code>ready = 1</code>, it will definitely see the properly prepared data. This is a fundamental principle in memory ordering.</p>
<h2 id="practical-example-a-simple-lock-free-counter">Practical Example: A Simple Lock-Free Counter</h2>
<p>Let&rsquo;s put it all together with a complete example of a lock-free counter:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Counter <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>Counter) <span style="color:#900;font-weight:bold">Increment</span>() <span style="color:#458;font-weight:bold">uint64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Get the current value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        current <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.value)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to increment it
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        next <span style="color:#000;font-weight:bold">:=</span> current <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.value, current, next) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> next <span style="color:#998;font-style:italic">// Return the new value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If we failed, someone else modified it - try again!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        runtime.<span style="color:#900;font-weight:bold">Gosched</span>() <span style="color:#998;font-style:italic">// Be nice to other goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>Counter) <span style="color:#900;font-weight:bold">Get</span>() <span style="color:#458;font-weight:bold">uint64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.value)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This counter can be safely used by multiple goroutines simultaneously, with no locks in sight!</p>
<h2 id="lock-free-vs-wait-free-understanding-the-distinction">Lock-Free vs. Wait-Free: Understanding the Distinction</h2>
<h3 id="the-progress-guarantee-spectrum">The Progress Guarantee Spectrum</h3>
<p>Imagine you&rsquo;re at a coffee shop. The way the shop handles customers can help us understand different types of progress guarantees:</p>
<ol>
<li>
<p><strong>Blocking (Lock-Based)</strong></p>
<ul>
<li>Like a coffee shop with one barista who can only serve one customer at a time</li>
<li>Everyone else must wait in line</li>
<li>If the barista takes a break (thread gets preempted), everyone&rsquo;s stuck!</li>
</ul>
</li>
<li>
<p><strong>Lock-Free</strong></p>
<ul>
<li>Like a coffee shop where multiple baristas share one coffee machine</li>
<li>If baristas collide, some might need to retry</li>
<li>But SOMEONE is always making progress</li>
<li>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">lockFreeIncrement</span>(value <span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">uint64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        current <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(value)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapUint64</span>(value, current, current<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>  <span style="color:#998;font-style:italic">// Success! But we might have had to retry
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else won the race - try again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Wait-Free</strong></p>
<ul>
<li>Like a coffee shop where each barista has their own machine</li>
<li>Everyone makes progress, no matter what</li>
<li>No retries needed, but more complex and resource-intensive</li>
<li>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Simplified wait-free increment using per-thread storage
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> WaitFreeCounter <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    counts [MaxThreads]<span style="color:#458;font-weight:bold">uint64</span>  <span style="color:#998;font-style:italic">// Each thread gets its own counter
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    total  <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="the-lock-free-guarantee">The Lock-Free Guarantee</h3>
<p>Let&rsquo;s implement a simple lock-free stack to understand the concept better:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Node <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value <span style="color:#458;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>    next  <span style="color:#000;font-weight:bold">*</span>Node
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Stack <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head <span style="color:#000;font-weight:bold">*</span>Node
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>Stack) <span style="color:#900;font-weight:bold">Push</span>(value <span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    node <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: value}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        head <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadPointer</span>((<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>s.head)))
</span></span><span style="display:flex;"><span>        node.next = (<span style="color:#000;font-weight:bold">*</span>Node)(head)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(
</span></span><span style="display:flex;"><span>            (<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>s.head)),
</span></span><span style="display:flex;"><span>            head,
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(node),
</span></span><span style="display:flex;"><span>        ) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If CAS failed, someone else modified the stack - try again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This stack is like a game of Jenga where players can add pieces simultaneously. Sometimes you might need to retry, but someone always succeeds.</p>
<h3 id="wait-free-algorithms-the-gold-standard">Wait-Free Algorithms: The Gold Standard</h3>
<p>Wait-free algorithms are like having an express lane for every customer. Here&rsquo;s a simplified wait-free counter:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> WaitFreeCounter <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    counters []<span style="color:#458;font-weight:bold">uint64</span>  <span style="color:#998;font-style:italic">// One counter per goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>WaitFreeCounter) <span style="color:#900;font-weight:bold">Increment</span>(goroutineID <span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    atomic.<span style="color:#900;font-weight:bold">AddUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.counters[goroutineID], <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// No retries needed! Each goroutine has its own counter
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>WaitFreeCounter) <span style="color:#900;font-weight:bold">GetTotal</span>() <span style="color:#458;font-weight:bold">uint64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">var</span> total <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> c.counters {
</span></span><span style="display:flex;"><span>        total <span style="color:#000;font-weight:bold">+=</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.counters[i])
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> total
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-aba-problem-a-classic-gotcha">The ABA Problem: A Classic Gotcha</h2>
<p>The ABA problem is like this scenario:</p>
<ol>
<li>You look at a coffee cup (it&rsquo;s blue)</li>
<li>You get distracted</li>
<li>Someone replaces it with a red cup</li>
<li>Someone replaces the red cup with a different blue cup</li>
<li>You come back and think nothing has changed!</li>
</ol>
<p>Here&rsquo;s how it can happen in code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Node <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value <span style="color:#458;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>    next  <span style="color:#000;font-weight:bold">*</span>Node
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Potential ABA problem in a lock-free stack
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>Stack) <span style="color:#900;font-weight:bold">Pop</span>() <span style="color:#000;font-weight:bold">*</span>Node {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        head <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadPointer</span>((<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>s.head)))
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> head <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        next <span style="color:#000;font-weight:bold">:=</span> (<span style="color:#000;font-weight:bold">*</span>Node)(head).next
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(
</span></span><span style="display:flex;"><span>            (<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>s.head)),
</span></span><span style="display:flex;"><span>            head,
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(next),
</span></span><span style="display:flex;"><span>        ) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> (<span style="color:#000;font-weight:bold">*</span>Node)(head)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The solution? Add a counter that changes with every modification:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> TaggedPointer <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    ptr   <span style="color:#000;font-weight:bold">*</span>Node
</span></span><span style="display:flex;"><span>    count <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="trade-offs-in-the-real-world">Trade-offs in the Real World</h2>
<p>Let&rsquo;s compare these approaches:</p>
<ol>
<li>
<p><strong>Lock-Free</strong></p>
<ul>
<li>Pros:
<ul>
<li>Simpler implementation</li>
<li>Lower memory overhead</li>
<li>Often good enough in practice</li>
</ul>
</li>
<li>Cons:
<ul>
<li>No guarantee against individual thread starvation</li>
<li>Can lead to lengthy retry loops</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Wait-Free</strong></p>
<ul>
<li>Pros:
<ul>
<li>Guaranteed progress for all threads</li>
<li>Predictable performance</li>
<li>Real-time system friendly</li>
</ul>
</li>
<li>Cons:
<ul>
<li>More complex implementation</li>
<li>Higher memory usage</li>
<li>Often slower in low-contention scenarios</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="making-the-choice-a-decision-framework">Making the Choice: A Decision Framework</h3>
<p>When should you choose each approach? Here&rsquo;s a simple decision tree:</p>
<ol>
<li>
<p>Choose Wait-Free when:</p>
<ul>
<li>You need real-time guarantees</li>
<li>Thread starvation is unacceptable</li>
<li>You have memory to spare</li>
</ul>
</li>
<li>
<p>Choose Lock-Free when:</p>
<ul>
<li>Average performance is more important than worst-case</li>
<li>Memory is constrained</li>
<li>Implementation simplicity is crucial</li>
</ul>
</li>
</ol>
<h2 id="building-blocks-in-go-your-concurrent-programming-toolkit">Building Blocks in Go: Your Concurrent Programming Toolkit</h2>
<p>Imagine you&rsquo;re building a house. You don&rsquo;t start with the roof – you need a strong foundation and the right tools first. In the world of lock-free programming, Go provides us with some powerful tools that act as our hammer, nails, and measuring tape. Let&rsquo;s explore them!</p>
<h3 id="atomic-operations-your-swiss-army-knife">Atomic Operations: Your Swiss Army Knife</h3>
<p>Remember playing with Lego blocks as a kid? Each piece snaps perfectly into place in one smooth motion. Atomic operations work the same way – they&rsquo;re operations that complete in one uninterruptible step. Go&rsquo;s sync/atomic package is our box of these special Lego pieces.</p>
<p>Here&rsquo;s a simple example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> counter <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// This is like snapping a Lego piece into place - one smooth motion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>atomic.<span style="color:#900;font-weight:bold">AddUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>counter, <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Instead of this risky two-step dance:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// counter = counter + 1  // Don&#39;t do this in concurrent code!
</span></span></span></code></pre></div><h3 id="memory-fences-the-traffic-lights-of-memory-access">Memory Fences: The Traffic Lights of Memory Access</h3>
<p>Think of memory fences like traffic lights at a busy intersection. They ensure cars (our data) move in an orderly fashion. In Go, atomic operations automatically include these &ldquo;traffic lights&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> data <span style="color:#458;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> ready <span style="color:#458;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">producer</span>() {
</span></span><span style="display:flex;"><span>    data = <span style="color:#099">42</span>                        <span style="color:#998;font-style:italic">// Set up the data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    atomic.<span style="color:#900;font-weight:bold">StoreUint32</span>(<span style="color:#000;font-weight:bold">&amp;</span>ready, <span style="color:#099">1</span>)    <span style="color:#998;font-style:italic">// Green light for readers!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">consumer</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">LoadUint32</span>(<span style="color:#000;font-weight:bold">&amp;</span>ready) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">1</span> {  <span style="color:#998;font-style:italic">// Check if light is green
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        fmt.<span style="color:#900;font-weight:bold">Println</span>(data)                <span style="color:#998;font-style:italic">// Safe to read data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="compare-and-swap-the-careful-craftsman">Compare-and-Swap: The Careful Craftsman</h3>
<p>Compare-and-Swap (CAS) is like a careful craftsman who follows a specific ritual:</p>
<ol>
<li>Look at the current value</li>
<li>Check if it matches what they expect</li>
<li>Only make changes if everything looks right</li>
</ol>
<p>Here&rsquo;s a real-world example – a thread-safe counter that never misses an increment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> PreciseCounter <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>PreciseCounter) <span style="color:#900;font-weight:bold">Increment</span>() <span style="color:#458;font-weight:bold">uint64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Take a snapshot of the current value
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        current <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.value)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to update it, but only if no one else has
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.value, current, current<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> current <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else changed it - let&#39;s try again!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="a-complete-example-building-a-thread-safe-stack">A Complete Example: Building a Thread-Safe Stack</h3>
<p>Let&rsquo;s put all these tools together to build something useful – a stack that multiple goroutines can safely use at the same time. Think of it like a stack of plates where multiple waiters can add or remove plates safely:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> LockFreeStack <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    top unsafe.Pointer  <span style="color:#998;font-style:italic">// Points to the top node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Node <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    next  unsafe.Pointer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>LockFreeStack) <span style="color:#900;font-weight:bold">Push</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>    newNode <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: value}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// See what&#39;s on top
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        oldTop <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadPointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>s.top)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Place our plate on top of the existing stack
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        newNode.next = oldTop
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to make our node the new top
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>s.top, oldTop, unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(newNode)) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else changed the stack - try again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="common-pitfalls-the-hidden-traps">Common Pitfalls: The Hidden Traps</h3>
<p>Just like a beautiful garden can hide thorny bushes, our concurrent tools come with their own hazards. Here&rsquo;s a classic trap:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// DON&#39;T DO THIS!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>value <span style="color:#000;font-weight:bold">:=</span> atomic.<span style="color:#900;font-weight:bold">LoadUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>counter)
</span></span><span style="display:flex;"><span>value<span style="color:#000;font-weight:bold">++</span>                              <span style="color:#998;font-style:italic">// Oops! Not atomic anymore
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>atomic.<span style="color:#900;font-weight:bold">StoreUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>counter, value)  <span style="color:#998;font-style:italic">// Too late, might have lost updates
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// DO THIS INSTEAD
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>atomic.<span style="color:#900;font-weight:bold">AddUint64</span>(<span style="color:#000;font-weight:bold">&amp;</span>counter, <span style="color:#099">1</span>)  <span style="color:#998;font-style:italic">// One smooth, atomic operation
</span></span></span></code></pre></div><p>It&rsquo;s like trying to juggle – you need to keep all the balls in the air at once. Drop one, and the whole pattern falls apart!</p>
<h2 id="lock-free-data-structure-implementations-building-thread-safe-collections">Lock-Free Data Structure Implementations: Building Thread-Safe Collections</h2>
<h3 id="the-lock-free-stack-our-first-adventure">The Lock-Free Stack: Our First Adventure</h3>
<p>Think of a stack like a Pringles can – typically, you can only add or remove chips from the top. But imagine a magical can where multiple people could safely add or remove chips simultaneously without any collisions. That&rsquo;s our lock-free stack!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> LockFreeStack <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    top atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Node <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value    <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    next     atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">NewLockFreeStack</span>() <span style="color:#000;font-weight:bold">*</span>LockFreeStack {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">&amp;</span>LockFreeStack{}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s implement the push operation first:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>LockFreeStack) <span style="color:#900;font-weight:bold">Push</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>    newNode <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: value}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Snapshot the current top
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        oldTop <span style="color:#000;font-weight:bold">:=</span> s.top.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Point our new node to the current top
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        newNode.next.<span style="color:#900;font-weight:bold">Store</span>(oldTop)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to update the top to our new node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> s.top.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(oldTop, newNode) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else won the race - try again!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And here&rsquo;s the pop operation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>LockFreeStack) <span style="color:#900;font-weight:bold">Pop</span>() <span style="color:#000;font-weight:bold">interface</span>{} {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        oldTop <span style="color:#000;font-weight:bold">:=</span> s.top.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> oldTop <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>  <span style="color:#998;font-style:italic">// Stack is empty
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to update top to the next node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> s.top.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(oldTop, oldTop.next.<span style="color:#900;font-weight:bold">Load</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> oldTop.value
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else modified the stack - try again!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="the-lock-free-queue-a-more-complex-beast">The Lock-Free Queue: A More Complex Beast</h3>
<p>If a stack is like a Pringles can, a queue is like a tube slide at a water park – people enter at one end and exit at the other. Our lock-free queue needs to handle both ends safely:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> LockFreeQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    tail atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">NewLockFreeQueue</span>() <span style="color:#000;font-weight:bold">*</span>LockFreeQueue {
</span></span><span style="display:flex;"><span>    dummy <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{}
</span></span><span style="display:flex;"><span>    q <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>LockFreeQueue{}
</span></span><span style="display:flex;"><span>    q.head.<span style="color:#900;font-weight:bold">Store</span>(dummy)
</span></span><span style="display:flex;"><span>    q.tail.<span style="color:#900;font-weight:bold">Store</span>(dummy)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> q
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s the enqueue operation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>LockFreeQueue) <span style="color:#900;font-weight:bold">Enqueue</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>    newNode <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: value}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        tail <span style="color:#000;font-weight:bold">:=</span> q.tail.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        next <span style="color:#000;font-weight:bold">:=</span> tail.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Make sure tail was still the tail
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> tail <span style="color:#000;font-weight:bold">==</span> q.tail.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> next <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#998;font-style:italic">// Try to link the new node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>                <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(
</span></span><span style="display:flex;"><span>                    (<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>tail.next)),
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">nil</span>,
</span></span><span style="display:flex;"><span>                    unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(newNode),
</span></span><span style="display:flex;"><span>                ) {
</span></span><span style="display:flex;"><span>                    <span style="color:#998;font-style:italic">// Try to swing the tail to the new node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>                    q.tail.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(tail, newNode)
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#998;font-style:italic">// Tail was falling behind, help move it
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>                q.tail.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(tail, next)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s break this down with a water park analogy:</p>
<ol>
<li>You want to add a new person (node) to the slide</li>
<li>You check the end of the line (tail)</li>
<li>If someone is secretly already there but not officially &ldquo;in line&rdquo;, help them first</li>
<li>Then add your person to the line</li>
</ol>
<h3 id="the-lock-free-linked-list-the-grand-challenge">The Lock-Free Linked List: The Grand Challenge</h3>
<p>A lock-free linked list is like a conga line where people can join or leave at any point. It&rsquo;s trickier because we need to handle changes in the middle of the structure:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> LockFreeList <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Node <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value    <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    next     atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    isMarked <span style="color:#458;font-weight:bold">bool</span>  <span style="color:#998;font-style:italic">// For safe deletion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>LockFreeList) <span style="color:#900;font-weight:bold">Insert</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        prev <span style="color:#000;font-weight:bold">:=</span> l.head.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        curr <span style="color:#000;font-weight:bold">:=</span> prev.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Find insertion point
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">for</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> curr.value.(<span style="color:#458;font-weight:bold">int</span>) &lt; value.(<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>            prev = curr
</span></span><span style="display:flex;"><span>            curr = curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Set up new node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        newNode <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: value}
</span></span><span style="display:flex;"><span>        newNode.next.<span style="color:#900;font-weight:bold">Store</span>(curr)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to insert
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> prev.next.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(curr, newNode) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone modified the list - try again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is complex stuff! Let&rsquo;s handle deletion:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>LockFreeList) <span style="color:#900;font-weight:bold">Delete</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        prev <span style="color:#000;font-weight:bold">:=</span> l.head.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        curr <span style="color:#000;font-weight:bold">:=</span> prev.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Find the node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">for</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> curr.value.(<span style="color:#458;font-weight:bold">int</span>) &lt; value.(<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>            prev = curr
</span></span><span style="display:flex;"><span>            curr = curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> curr <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">||</span> curr.value <span style="color:#000;font-weight:bold">!=</span> value {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>  <span style="color:#998;font-style:italic">// Not found
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Mark for deletion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        curr.isMarked = <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to unlink
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        next <span style="color:#000;font-weight:bold">:=</span> curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> prev.next.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(curr, next) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone modified the list - try again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="memory-management-the-cleanup-crew">Memory Management: The Cleanup Crew</h3>
<p>Just like a water park needs cleanup crews, our lock-free structures need memory management. In Go, we rely on the garbage collector, but we need to be careful about the ABA problem:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> TaggedPointer <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    ptr   <span style="color:#000;font-weight:bold">*</span>Node
</span></span><span style="display:flex;"><span>    count <span style="color:#458;font-weight:bold">uint64</span>  <span style="color:#998;font-style:italic">// Changes with every modification
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>This is like giving each person in line a unique ticket number – even if they leave and come back, we&rsquo;ll know they&rsquo;re not the same instance!</p>
<h2 id="implementing-a-lock-free-linked-list">Implementing a Lock-Free Linked List</h2>
<p>Here&rsquo;s a complete implementation of a lock-free linked list with safe memory management:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;sync/atomic&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Node represents a node in the lock-free linked list
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> Node <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value    <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    next     atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    deleted  atomic.Bool <span style="color:#998;font-style:italic">// Marked true during deletion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// SafeList implements a lock-free linked list
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> SafeList <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// NewSafeList creates a new empty SafeList
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">NewSafeList</span>() <span style="color:#000;font-weight:bold">*</span>SafeList {
</span></span><span style="display:flex;"><span>    list <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>SafeList{}
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Initialize with a sentinel node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    sentinel <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: <span style="color:#000;font-weight:bold">nil</span>}
</span></span><span style="display:flex;"><span>    list.head.<span style="color:#900;font-weight:bold">Store</span>(sentinel)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> list
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Insert adds a new value to the list in sorted order
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Returns true if the value was inserted, false if it already exists
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Thread-safety: Safe to call from multiple goroutines.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Progress: Lock-free. Completes in O(n) steps.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>SafeList) <span style="color:#900;font-weight:bold">Insert</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    node <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Node{value: value}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Find the insertion point
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        prev, curr <span style="color:#000;font-weight:bold">:=</span> l.<span style="color:#900;font-weight:bold">findInsertionPoint</span>(value)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> curr.value <span style="color:#000;font-weight:bold">==</span> value <span style="color:#000;font-weight:bold">&amp;&amp;</span> !curr.deleted.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span> <span style="color:#998;font-style:italic">// Value already exists
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Link the new node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        node.next.<span style="color:#900;font-weight:bold">Store</span>(curr)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to update prev.next to point to our new node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(
</span></span><span style="display:flex;"><span>            (<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>prev.next)),
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(curr),
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(node)) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        runtime.<span style="color:#900;font-weight:bold">Gosched</span>() <span style="color:#998;font-style:italic">// Be nice to other goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Delete removes a value from the list
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Returns true if the value was deleted, false if it wasn&#39;t found
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Thread-safety: Safe to call from multiple goroutines.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Progress: Lock-free. Completes in O(n) steps.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>SafeList) <span style="color:#900;font-weight:bold">Delete</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        prev <span style="color:#000;font-weight:bold">:=</span> l.head.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        curr <span style="color:#000;font-weight:bold">:=</span> prev.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Find the node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">for</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> curr.value.(<span style="color:#458;font-weight:bold">int</span>) &lt; value.(<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>            prev = curr
</span></span><span style="display:flex;"><span>            curr = curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> curr <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">||</span> curr.value <span style="color:#000;font-weight:bold">!=</span> value {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span> <span style="color:#998;font-style:italic">// Not found
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Mark the node as deleted
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> !curr.deleted.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(<span style="color:#000;font-weight:bold">false</span>, <span style="color:#000;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span> <span style="color:#998;font-style:italic">// Already deleted
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Try to unlink the node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        next <span style="color:#000;font-weight:bold">:=</span> curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(
</span></span><span style="display:flex;"><span>            (<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>prev.next)),
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(curr),
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(next)) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        runtime.<span style="color:#900;font-weight:bold">Gosched</span>() <span style="color:#998;font-style:italic">// Be nice to other goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Find returns true if the value exists in the list
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>SafeList) <span style="color:#900;font-weight:bold">Find</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    curr <span style="color:#000;font-weight:bold">:=</span> l.head.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> curr.value <span style="color:#000;font-weight:bold">==</span> value <span style="color:#000;font-weight:bold">&amp;&amp;</span> !curr.deleted.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        curr = curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// findInsertionPoint finds the position where a value should be inserted
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Returns the previous and current nodes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>SafeList) <span style="color:#900;font-weight:bold">findInsertionPoint</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) (<span style="color:#000;font-weight:bold">*</span>Node, <span style="color:#000;font-weight:bold">*</span>Node) {
</span></span><span style="display:flex;"><span>retry:
</span></span><span style="display:flex;"><span>    prev <span style="color:#000;font-weight:bold">:=</span> l.head.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    curr <span style="color:#000;font-weight:bold">:=</span> prev.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Skip deleted nodes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> curr.deleted.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// Try to unlink the deleted node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            next <span style="color:#000;font-weight:bold">:=</span> curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> !atomic.<span style="color:#900;font-weight:bold">CompareAndSwapPointer</span>(
</span></span><span style="display:flex;"><span>                (<span style="color:#000;font-weight:bold">*</span>unsafe.Pointer)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>prev.next)),
</span></span><span style="display:flex;"><span>                unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(curr),
</span></span><span style="display:flex;"><span>                unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(next)) {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">goto</span> retry <span style="color:#998;font-style:italic">// Someone else modified the list, retry
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            curr = next
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Compare values for sorted insertion
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">switch</span> curr.value.(<span style="color:#000;font-weight:bold">type</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#458;font-weight:bold">int</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> curr.value.(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">&gt;=</span> value.(<span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> prev, curr
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#458;font-weight:bold">string</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> curr.value.(<span style="color:#458;font-weight:bold">string</span>) <span style="color:#000;font-weight:bold">&gt;=</span> value.(<span style="color:#458;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> prev, curr
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// For non-comparable types, just append to the end
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="color:#000;font-weight:bold">if</span> curr.next.<span style="color:#900;font-weight:bold">Load</span>() <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> curr, <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        prev = curr
</span></span><span style="display:flex;"><span>        curr = curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> prev, curr
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This implementation includes several important features:</p>
<ol>
<li><strong>Safe Memory Management</strong>: Uses atomic pointers and deletion markers to prevent ABA problems</li>
<li><strong>Type-Safe Operations</strong>: Handles different comparable types appropriately</li>
<li><strong>Garbage Collection Friendly</strong>: Marks nodes as deleted before unlinking them</li>
<li><strong>Lock-Free Progress</strong>: All operations can proceed without locks</li>
<li><strong>Memory Ordering</strong>: Proper use of atomic operations ensures correct visibility</li>
</ol>
<h2 id="understanding-wait-free-a-fresh-perspective">Understanding Wait-Free: A Fresh Perspective</h2>
<p>Imagine a busy restaurant with an innovative ordering system. In a normal restaurant, if one waiter gets stuck with a difficult customer, other waiters might have to wait. But in our wait-free restaurant, every waiter is guaranteed to complete their task in a fixed number of steps, no matter what other waiters are doing.</p>
<h2 id="wait-free-universal-construction">Wait-Free Universal Construction</h2>
<p>Let&rsquo;s start with something mind-bending – a technique that can transform any data structure into a wait-free version. Think of it like a magical recipe that can turn any regular dish into one that can be cooked simultaneously by multiple chefs without conflicts:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Operation <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    id        <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">type</span>      OperationType
</span></span><span style="display:flex;"><span>    data      <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    completed atomic.Bool
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> WaitFreeStructure <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    operations []atomic.Pointer[Operation]
</span></span><span style="display:flex;"><span>    results    []atomic.Value
</span></span><span style="display:flex;"><span>    current    atomic.Int64
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (w <span style="color:#000;font-weight:bold">*</span>WaitFreeStructure) <span style="color:#900;font-weight:bold">Apply</span>(op <span style="color:#000;font-weight:bold">*</span>Operation) <span style="color:#000;font-weight:bold">interface</span>{} {
</span></span><span style="display:flex;"><span>    myPosition <span style="color:#000;font-weight:bold">:=</span> w.current.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>    w.operations[myPosition].<span style="color:#900;font-weight:bold">Store</span>(op)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Help complete all operations up to ours
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">int64</span>(<span style="color:#099">0</span>); i <span style="color:#000;font-weight:bold">&lt;=</span> myPosition; i<span style="color:#000;font-weight:bold">++</span> {
</span></span><span style="display:flex;"><span>        w.<span style="color:#900;font-weight:bold">helpComplete</span>(i)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> w.results[myPosition].<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The key idea here is &ldquo;helping&rdquo; – if you see an operation that&rsquo;s not complete, you help finish it before moving on. It&rsquo;s like seeing a fellow chef struggling and jumping in to help them finish their dish!</p>
<h2 id="a-practical-wait-free-queue">A Practical Wait-Free Queue</h2>
<p>Here&rsquo;s a simplified wait-free queue that guarantees progress for every operation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> WaitFreeQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    slots    []atomic.Value
</span></span><span style="display:flex;"><span>    enqIdx   atomic.Uint64
</span></span><span style="display:flex;"><span>    deqIdx   atomic.Uint64
</span></span><span style="display:flex;"><span>    capacity <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>WaitFreeQueue) <span style="color:#900;font-weight:bold">Enqueue</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        idx <span style="color:#000;font-weight:bold">:=</span> q.enqIdx.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> idx<span style="color:#000;font-weight:bold">-</span>q.deqIdx.<span style="color:#900;font-weight:bold">Load</span>() <span style="color:#000;font-weight:bold">&gt;=</span> q.capacity {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>  <span style="color:#998;font-style:italic">// Queue is full
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        slot <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>q.slots[idx<span style="color:#000;font-weight:bold">%</span>q.capacity]
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> slot.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(<span style="color:#000;font-weight:bold">nil</span>, value) {
</span></span><span style="display:flex;"><span>            q.enqIdx.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else took our slot - move forward
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        q.enqIdx.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is like having an infinite row of empty boxes moving on a conveyor belt. Each person (thread) is guaranteed to find an empty box within a fixed number of steps!</p>
<h2 id="multi-word-compare-and-swap">Multi-Word Compare-and-Swap</h2>
<p>Sometimes we need to update multiple values atomically. Imagine coordinating multiple traffic lights to change simultaneously:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> WCAS2[T any] <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    loc1, loc2 <span style="color:#000;font-weight:bold">*</span>atomic.Pointer[T]
</span></span><span style="display:flex;"><span>    old1, old2 <span style="color:#000;font-weight:bold">*</span>T
</span></span><span style="display:flex;"><span>    new1, new2 <span style="color:#000;font-weight:bold">*</span>T
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>WCAS2[T]) <span style="color:#900;font-weight:bold">Try</span>() <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Phase 1: Announce our intention
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    descriptor <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>WCASDescriptor[T]{
</span></span><span style="display:flex;"><span>        locations: [<span style="color:#099">2</span>]<span style="color:#000;font-weight:bold">*</span>atomic.Pointer[T]{c.loc1, c.loc2},
</span></span><span style="display:flex;"><span>        oldValues: [<span style="color:#099">2</span>]<span style="color:#000;font-weight:bold">*</span>T{c.old1, c.old2},
</span></span><span style="display:flex;"><span>        newValues: [<span style="color:#099">2</span>]<span style="color:#000;font-weight:bold">*</span>T{c.new1, c.new2},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Phase 2: Try to lock locations
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; i &lt; <span style="color:#099">2</span>; i<span style="color:#000;font-weight:bold">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> descriptor.<span style="color:#900;font-weight:bold">Complete</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> descriptor.<span style="color:#900;font-weight:bold">Failed</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// Try to lock location i
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="color:#998;font-style:italic">// Help anyone else we see along the way
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> descriptor.<span style="color:#900;font-weight:bold">Complete</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-helping-mechanism-being-a-good-neighbor">The Helping Mechanism: Being a Good Neighbor</h2>
<p>The secret sauce of wait-free algorithms is helping others. It&rsquo;s like a neighborhood where everyone shovels snow from their sidewalk and helps their neighbors too:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (w <span style="color:#000;font-weight:bold">*</span>WaitFreeStructure) <span style="color:#900;font-weight:bold">helpComplete</span>(position <span style="color:#458;font-weight:bold">int64</span>) {
</span></span><span style="display:flex;"><span>    op <span style="color:#000;font-weight:bold">:=</span> w.operations[position].<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> op <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">||</span> op.completed.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Apply the operation
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    result <span style="color:#000;font-weight:bold">:=</span> w.<span style="color:#900;font-weight:bold">applyOperation</span>(op)
</span></span><span style="display:flex;"><span>    w.results[position].<span style="color:#900;font-weight:bold">Store</span>(result)
</span></span><span style="display:flex;"><span>    op.completed.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="elimination-a-clever-shortcut">Elimination: A Clever Shortcut</h2>
<p>Sometimes, operations can cancel each other out. Imagine a stack where a push and pop arrive simultaneously – why not just hand the value directly from pusher to popper?</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> EliminationArray <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    slots []atomic.Value
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (e <span style="color:#000;font-weight:bold">*</span>EliminationArray) <span style="color:#900;font-weight:bold">TryEliminate</span>(op Operation, value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#000;font-weight:bold">interface</span>{} {
</span></span><span style="display:flex;"><span>    slot <span style="color:#000;font-weight:bold">:=</span> rand.<span style="color:#900;font-weight:bold">Intn</span>(<span style="color:#0086b3">len</span>(e.slots))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> op <span style="color:#000;font-weight:bold">==</span> Push {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> e.slots[slot].<span style="color:#900;font-weight:bold">CompareAndSwap</span>(<span style="color:#000;font-weight:bold">nil</span>, value) {
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// Wait briefly for a matching pop
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            time.<span style="color:#900;font-weight:bold">Sleep</span>(time.Microsecond)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> e.slots[slot].<span style="color:#900;font-weight:bold">CompareAndSwap</span>(value, <span style="color:#000;font-weight:bold">nil</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#998;font-style:italic">// No match found
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> value <span style="color:#998;font-style:italic">// Successfully eliminated!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Similar logic for Pop...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>This is like having a &ldquo;fast lane&rdquo; where people can directly exchange items without going through the main structure!</p>
<h2 id="the-memory-management-challenge">The Memory Management Challenge</h2>
<p>Imagine you&rsquo;re playing a game of hot potato, but with a twist. Sometimes players might look down at their hands and find they&rsquo;re holding a potato that was thrown away ages ago! This is exactly the problem we face with memory in lock-free programming.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">dangerousCode</span>() {
</span></span><span style="display:flex;"><span>    node <span style="color:#000;font-weight:bold">:=</span> list.head.<span style="color:#900;font-weight:bold">Load</span>()  <span style="color:#998;font-style:italic">// Get a node reference
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// ... meanwhile, another thread removes and deletes this node ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    fmt.<span style="color:#900;font-weight:bold">Println</span>(node.value)   <span style="color:#998;font-style:italic">// Oops! Accessing freed memory!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="hazard-pointers-your-memory-safety-guard">Hazard Pointers: Your Memory Safety Guard</h2>
<p>Think of hazard pointers like putting a &ldquo;Do Not Touch!&rdquo; sticky note on objects you&rsquo;re using. Here&rsquo;s how we implement them in Go:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> HazardPointer <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    pointer atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    active  atomic.Bool
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> HazardManager <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    hazards    [MaxThreads]HazardPointer
</span></span><span style="display:flex;"><span>    retired    []unsafe.Pointer
</span></span><span style="display:flex;"><span>    retireLock sync.Mutex
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (hm <span style="color:#000;font-weight:bold">*</span>HazardManager) <span style="color:#900;font-weight:bold">Protect</span>(ptr <span style="color:#000;font-weight:bold">*</span>Node) <span style="color:#000;font-weight:bold">*</span>Node {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Mark this pointer as being used
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    myHazard <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>hm.hazards[<span style="color:#900;font-weight:bold">getCurrentThreadID</span>()]
</span></span><span style="display:flex;"><span>    myHazard.pointer.<span style="color:#900;font-weight:bold">Store</span>(ptr)
</span></span><span style="display:flex;"><span>    myHazard.active.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Double-check the pointer is still valid
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> !<span style="color:#900;font-weight:bold">isStillValid</span>(ptr) {
</span></span><span style="display:flex;"><span>        myHazard.active.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">false</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> ptr
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="epoch-based-reclamation-time-travel-safety">Epoch-Based Reclamation: Time-Travel Safety</h2>
<p>Epoch-based reclamation is like having a time-stamped security system. Instead of protecting individual objects, we protect time periods:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Epoch <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    current atomic.Uint64
</span></span><span style="display:flex;"><span>    slots   [<span style="color:#099">3</span>][]unsafe.Pointer  <span style="color:#998;font-style:italic">// Three epochs worth of retired nodes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (e <span style="color:#000;font-weight:bold">*</span>Epoch) <span style="color:#900;font-weight:bold">Enter</span>() <span style="color:#458;font-weight:bold">uint64</span> {
</span></span><span style="display:flex;"><span>    epoch <span style="color:#000;font-weight:bold">:=</span> e.current.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Announce we&#39;re in this epoch
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    myEpochAnnouncement.<span style="color:#900;font-weight:bold">Store</span>(epoch)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> epoch
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (e <span style="color:#000;font-weight:bold">*</span>Epoch) <span style="color:#900;font-weight:bold">Retire</span>(ptr unsafe.Pointer, epoch <span style="color:#458;font-weight:bold">uint64</span>) {
</span></span><span style="display:flex;"><span>    slot <span style="color:#000;font-weight:bold">:=</span> epoch <span style="color:#000;font-weight:bold">%</span> <span style="color:#099">3</span>
</span></span><span style="display:flex;"><span>    e.slots[slot] = <span style="color:#0086b3">append</span>(e.slots[slot], ptr)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// If all threads have moved past this epoch,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// we can safely free everything in this slot
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">canFreeEpoch</span>(epoch) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">freeAll</span>(e.slots[slot])
</span></span><span style="display:flex;"><span>        e.slots[slot] = <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="reference-counting-the-collective-tracking-approach">Reference Counting: The Collective Tracking Approach</h2>
<p>Sometimes we need to keep count of how many threads are using an object, like keeping track of how many people are in a room:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> RefCountedNode <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value     <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    next      <span style="color:#000;font-weight:bold">*</span>RefCountedNode
</span></span><span style="display:flex;"><span>    refCount  atomic.Int32
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (n <span style="color:#000;font-weight:bold">*</span>RefCountedNode) <span style="color:#900;font-weight:bold">Acquire</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        count <span style="color:#000;font-weight:bold">:=</span> n.refCount.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> count <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#099">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#0086b3">panic</span>(<span style="color:#d14">&#34;Acquiring a deleted node!&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> n.refCount.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(count, count<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (n <span style="color:#000;font-weight:bold">*</span>RefCountedNode) <span style="color:#900;font-weight:bold">Release</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> n.refCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Last reference, safe to delete
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">free</span>(n)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="a-complete-example-safe-node-removal">A Complete Example: Safe Node Removal</h2>
<p>Let&rsquo;s put it all together with a complete example of safe node removal in a lock-free linked list:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> SafeList <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head   atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    epochs <span style="color:#000;font-weight:bold">*</span>Epoch
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (l <span style="color:#000;font-weight:bold">*</span>SafeList) <span style="color:#900;font-weight:bold">Remove</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    epoch <span style="color:#000;font-weight:bold">:=</span> l.epochs.<span style="color:#900;font-weight:bold">Enter</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">defer</span> l.epochs.<span style="color:#900;font-weight:bold">Exit</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    prev <span style="color:#000;font-weight:bold">:=</span> l.head.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    curr <span style="color:#000;font-weight:bold">:=</span> prev.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> curr <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> curr.value <span style="color:#000;font-weight:bold">==</span> value {
</span></span><span style="display:flex;"><span>            next <span style="color:#000;font-weight:bold">:=</span> curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> prev.next.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(curr, next) {
</span></span><span style="display:flex;"><span>                <span style="color:#998;font-style:italic">// Successfully unlinked, retire the node
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>                l.epochs.<span style="color:#900;font-weight:bold">Retire</span>(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(curr), epoch)
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        prev = curr
</span></span><span style="display:flex;"><span>        curr = curr.next.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="best-practices-and-design-patterns-making-smart-choices-in-lock-free-programming">Best Practices and Design Patterns: Making Smart Choices in Lock-Free Programming</h2>
<p>Imagine you&rsquo;re a chef deciding whether to cook a complex dish or order takeout. Similarly, when building concurrent systems, you need to know when to use lock-free structures and when to stick with simpler solutions. Let&rsquo;s explore this through practical examples and real-world scenarios.</p>
<h2 id="when-to-go-lock-free">When to Go Lock-Free</h2>
<p>Let&rsquo;s start with a simple decision framework, presented as a story:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Scenario 1: Simple counter with low contention
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> SimpleCounter <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value <span style="color:#458;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>    mutex sync.Mutex
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// This is probably fine! Don&#39;t overcomplicate it
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>SimpleCounter) <span style="color:#900;font-weight:bold">Increment</span>() {
</span></span><span style="display:flex;"><span>    c.mutex.<span style="color:#900;font-weight:bold">Lock</span>()
</span></span><span style="display:flex;"><span>    c.value<span style="color:#000;font-weight:bold">++</span>
</span></span><span style="display:flex;"><span>    c.mutex.<span style="color:#900;font-weight:bold">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Scenario 2: High-performance queue with many producers/consumers
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> HighPerformanceQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    tail atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Now we&#39;re talking! Lock-free makes sense here
</span></span></span></code></pre></div><p>Think of it like choosing transportation: you don&rsquo;t need a Formula 1 car to drive to the grocery store, but you might want one for a racing championship!</p>
<h2 id="design-considerations-the-architecture-phase">Design Considerations: The Architecture Phase</h2>
<p>When building lock-free structures, think like a building architect:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Bad: Mixing locks and lock-free operations
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> HybridStack <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    top  atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    size <span style="color:#458;font-weight:bold">int</span>  <span style="color:#998;font-style:italic">// Oops! This needs synchronization
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Good: Fully lock-free design
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> CleanStack <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    top atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Size is calculated on demand or tracked atomically
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    size atomic.Int64
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (s <span style="color:#000;font-weight:bold">*</span>CleanStack) <span style="color:#900;font-weight:bold">Size</span>() <span style="color:#458;font-weight:bold">int64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> s.size.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="testing-strategies-catching-the-invisible-bugs">Testing Strategies: Catching the Invisible Bugs</h2>
<p>Testing concurrent code is like trying to catch a ghost – the problems are often invisible until they suddenly appear! Here&rsquo;s how we approach it:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestConcurrentStack</span>(t <span style="color:#000;font-weight:bold">*</span>testing.T) {
</span></span><span style="display:flex;"><span>    stack <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">NewLockFreeStack</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> numGoroutines = <span style="color:#099">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">const</span> opsPerGoroutine = <span style="color:#099">1000</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Use a WaitGroup to synchronize goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">var</span> wg sync.WaitGroup
</span></span><span style="display:flex;"><span>    wg.<span style="color:#900;font-weight:bold">Add</span>(numGoroutines)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Launch multiple goroutines
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; i &lt; numGoroutines; i<span style="color:#000;font-weight:bold">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">go</span> <span style="color:#000;font-weight:bold">func</span>(id <span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">defer</span> wg.<span style="color:#900;font-weight:bold">Done</span>()
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// Mix operations to create contention
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; j &lt; opsPerGoroutine; j<span style="color:#000;font-weight:bold">++</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> j<span style="color:#000;font-weight:bold">%</span><span style="color:#099">2</span> <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
</span></span><span style="display:flex;"><span>                    stack.<span style="color:#900;font-weight:bold">Push</span>(j)
</span></span><span style="display:flex;"><span>                } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                    stack.<span style="color:#900;font-weight:bold">Pop</span>()
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }(i)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    wg.<span style="color:#900;font-weight:bold">Wait</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Verify final state
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="debugging-techniques-finding-the-invisible">Debugging Techniques: Finding the Invisible</h2>
<p>Debugging lock-free code is like being a detective. Here&rsquo;s our toolkit:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> DebugNode <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value     <span style="color:#000;font-weight:bold">interface</span>{}
</span></span><span style="display:flex;"><span>    next      atomic.Pointer[DebugNode]
</span></span><span style="display:flex;"><span>    debugInfo <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>        threadID    <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>        operationID <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>        timestamp   <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (n <span style="color:#000;font-weight:bold">*</span>DebugNode) <span style="color:#900;font-weight:bold">String</span>() <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> fmt.<span style="color:#900;font-weight:bold">Sprintf</span>(<span style="color:#d14">&#34;Node[value=%v, thread=%d, op=%d, time=%d]&#34;</span>,
</span></span><span style="display:flex;"><span>        n.value, n.debugInfo.threadID, 
</span></span><span style="display:flex;"><span>        n.debugInfo.operationID, n.debugInfo.timestamp)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="documentation-your-future-self-will-thank-you">Documentation: Your Future Self Will Thank You</h2>
<p>Good documentation is like leaving a map for future explorers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// LockFreeQueue implements a multi-producer, multi-consumer queue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// with the following guarantees:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//   1. Wait-free enqueue operations
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//   2. Lock-free dequeue operations
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//   3. Preservation of FIFO ordering
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Memory ordering: All operations use acquire/release semantics.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ABA prevention: Uses tagged pointers with a 16-bit counter.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> LockFreeQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    head atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    tail atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Enqueue adds an item to the queue.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Returns true if successful, false if the queue is full.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Thread-safety: Safe to call from multiple goroutines.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Progress: Wait-free. Completes in O(1) steps.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>LockFreeQueue) <span style="color:#900;font-weight:bold">Enqueue</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Implementation...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h2 id="real-world-integration-tips">Real-World Integration Tips</h2>
<p>When integrating lock-free structures into existing systems:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Wrapper pattern for gradual adoption
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> SafeWrapper <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    internal    <span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    monitoring  <span style="color:#000;font-weight:bold">*</span>Metrics
</span></span><span style="display:flex;"><span>    isEnabled   atomic.Bool
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (w <span style="color:#000;font-weight:bold">*</span>SafeWrapper) <span style="color:#900;font-weight:bold">Enqueue</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> w.isEnabled.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        start <span style="color:#000;font-weight:bold">:=</span> time.<span style="color:#900;font-weight:bold">Now</span>()
</span></span><span style="display:flex;"><span>        result <span style="color:#000;font-weight:bold">:=</span> w.internal.<span style="color:#900;font-weight:bold">Enqueue</span>(value)
</span></span><span style="display:flex;"><span>        w.monitoring.<span style="color:#900;font-weight:bold">RecordLatency</span>(<span style="color:#d14">&#34;enqueue&#34;</span>, time.<span style="color:#900;font-weight:bold">Since</span>(start))
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> result
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Fallback to traditional implementation
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> w.<span style="color:#900;font-weight:bold">legacyEnqueue</span>(value)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="real-world-applications-lock-free-programming-in-the-wild">Real-World Applications: Lock-Free Programming in the Wild</h2>
<p>Let&rsquo;s dive into some real-world scenarios where lock-free programming shines. Think of these as cooking recipes that have been battle-tested in professional kitchens!</p>
<h3 id="case-study-1-high-performance-message-queue">Case Study 1: High-Performance Message Queue</h3>
<p>Imagine you&rsquo;re building a system like Discord, where millions of messages need to be processed in real-time:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> MessageBroker <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    queues    []<span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    producers atomic.Uint64
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (mb <span style="color:#000;font-weight:bold">*</span>MessageBroker) <span style="color:#900;font-weight:bold">PublishMessage</span>(msg Message) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Distribute messages across queues using a lock-free approach
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    queueIndex <span style="color:#000;font-weight:bold">:=</span> mb.producers.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">%</span> <span style="color:#0086b3">uint64</span>(<span style="color:#0086b3">len</span>(mb.queues))
</span></span><span style="display:flex;"><span>    queue <span style="color:#000;font-weight:bold">:=</span> mb.queues[queueIndex]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> !queue.<span style="color:#900;font-weight:bold">Enqueue</span>(msg) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If queue is full, try next one
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        queueIndex = (queueIndex <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">%</span> <span style="color:#0086b3">uint64</span>(<span style="color:#0086b3">len</span>(mb.queues))
</span></span><span style="display:flex;"><span>        queue = mb.queues[queueIndex]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is like having multiple conveyor belts in a package sorting facility – if one belt gets full, packages automatically go to the next one!</p>
<h3 id="case-study-2-real-time-gaming-server">Case Study 2: Real-Time Gaming Server</h3>
<p>Here&rsquo;s how a game server might track player positions without locking:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> PlayerPosition <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    x, y, z atomic.Float64
</span></span><span style="display:flex;"><span>    updated atomic.Int64
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> GameWorld <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    players <span style="color:#000;font-weight:bold">map</span>[PlayerID]<span style="color:#000;font-weight:bold">*</span>PlayerPosition
</span></span><span style="display:flex;"><span>    grid    [][]<span style="color:#000;font-weight:bold">*</span>atomic.Pointer[PlayerList]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (w <span style="color:#000;font-weight:bold">*</span>GameWorld) <span style="color:#900;font-weight:bold">UpdatePosition</span>(playerID PlayerID, x, y, z <span style="color:#458;font-weight:bold">float64</span>) {
</span></span><span style="display:flex;"><span>    pos <span style="color:#000;font-weight:bold">:=</span> w.players[playerID]
</span></span><span style="display:flex;"><span>    pos.x.<span style="color:#900;font-weight:bold">Store</span>(x)
</span></span><span style="display:flex;"><span>    pos.y.<span style="color:#900;font-weight:bold">Store</span>(y)
</span></span><span style="display:flex;"><span>    pos.z.<span style="color:#900;font-weight:bold">Store</span>(z)
</span></span><span style="display:flex;"><span>    pos.updated.<span style="color:#900;font-weight:bold">Store</span>(time.<span style="color:#900;font-weight:bold">Now</span>().<span style="color:#900;font-weight:bold">UnixNano</span>())
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Update grid position without locks
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    w.<span style="color:#900;font-weight:bold">updateGrid</span>(playerID, x, y, z)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Think of it like an air traffic control system where each plane&rsquo;s position needs to be updated without making other planes wait!</p>
<h3 id="case-study-3-high-frequency-trading-system">Case Study 3: High-Frequency Trading System</h3>
<p>Here&rsquo;s a simplified version of how trading systems handle orders:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> OrderBook <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    buyOrders  <span style="color:#000;font-weight:bold">*</span>LockFreeSkipList
</span></span><span style="display:flex;"><span>    sellOrders <span style="color:#000;font-weight:bold">*</span>LockFreeSkipList
</span></span><span style="display:flex;"><span>    trades     <span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (ob <span style="color:#000;font-weight:bold">*</span>OrderBook) <span style="color:#900;font-weight:bold">PlaceOrder</span>(order Order) <span style="color:#000;font-weight:bold">*</span>Trade {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> order.Type <span style="color:#000;font-weight:bold">==</span> Buy {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Look for matching sell orders
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        match <span style="color:#000;font-weight:bold">:=</span> ob.sellOrders.<span style="color:#900;font-weight:bold">FindAndRemove</span>(<span style="color:#000;font-weight:bold">func</span>(o Order) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> o.Price <span style="color:#000;font-weight:bold">&lt;=</span> order.Price
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> match <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            trade <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>Trade{BuyOrder: order, SellOrder: match}
</span></span><span style="display:flex;"><span>            ob.trades.<span style="color:#900;font-weight:bold">Enqueue</span>(trade)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> trade
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// No match, add to buy orders
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        ob.buyOrders.<span style="color:#900;font-weight:bold">Insert</span>(order)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Similar logic for sell orders...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is like a super-fast matchmaking system for buyers and sellers where every microsecond counts!</p>
<h3 id="integration-with-existing-codebases">Integration with Existing Codebases</h3>
<p>Here&rsquo;s how you might gradually introduce lock-free structures into an existing system:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> HybridCache <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    modern  <span style="color:#000;font-weight:bold">*</span>LockFreeHashMap
</span></span><span style="display:flex;"><span>    legacy  <span style="color:#000;font-weight:bold">*</span>sync.Map
</span></span><span style="display:flex;"><span>    useModern atomic.Bool
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>HybridCache) <span style="color:#900;font-weight:bold">Get</span>(key <span style="color:#000;font-weight:bold">interface</span>{}) (<span style="color:#000;font-weight:bold">interface</span>{}, <span style="color:#458;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> c.useModern.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> c.modern.<span style="color:#900;font-weight:bold">Get</span>(key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> c.legacy.<span style="color:#900;font-weight:bold">Load</span>(key)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>HybridCache) <span style="color:#900;font-weight:bold">EnableModernCache</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Migrate data in the background
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">go</span> <span style="color:#000;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>        c.legacy.<span style="color:#900;font-weight:bold">Range</span>(<span style="color:#000;font-weight:bold">func</span>(key, value <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>            c.modern.<span style="color:#900;font-weight:bold">Put</span>(key, value)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        c.useModern.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="monitoring-and-observability">Monitoring and Observability</h3>
<p>Just like a Formula 1 car needs telemetry, lock-free systems need monitoring:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> MetricsCollector <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    operations atomic.Uint64
</span></span><span style="display:flex;"><span>    retries    atomic.Uint64
</span></span><span style="display:flex;"><span>    latencies  <span style="color:#000;font-weight:bold">*</span>LockFreeHistogram
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (mc <span style="color:#000;font-weight:bold">*</span>MetricsCollector) <span style="color:#900;font-weight:bold">RecordOperation</span>(start time.Time, retryCount <span style="color:#458;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    mc.operations.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    mc.retries.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#0086b3">uint64</span>(retryCount))
</span></span><span style="display:flex;"><span>    mc.latencies.<span style="color:#900;font-weight:bold">Record</span>(time.<span style="color:#900;font-weight:bold">Since</span>(start).<span style="color:#900;font-weight:bold">Microseconds</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (mc <span style="color:#000;font-weight:bold">*</span>MetricsCollector) <span style="color:#900;font-weight:bold">GetMetrics</span>() Metrics {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> Metrics{
</span></span><span style="display:flex;"><span>        OperationCount: mc.operations.<span style="color:#900;font-weight:bold">Load</span>(),
</span></span><span style="display:flex;"><span>        RetryRate: <span style="color:#0086b3">float64</span>(mc.retries.<span style="color:#900;font-weight:bold">Load</span>()) <span style="color:#000;font-weight:bold">/</span> <span style="color:#0086b3">float64</span>(mc.operations.<span style="color:#900;font-weight:bold">Load</span>()),
</span></span><span style="display:flex;"><span>        AverageLatency: mc.latencies.<span style="color:#900;font-weight:bold">Average</span>(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="failure-modes-and-recovery">Failure Modes and Recovery</h3>
<p>Even the best systems can fail. Here&rsquo;s how we handle failures gracefully:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> ResilientQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    primary   <span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    backup    <span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    isHealthy atomic.Bool
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">Enqueue</span>(item <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> !q.isHealthy.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Try primary queue first
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> q.primary.<span style="color:#900;font-weight:bold">Enqueue</span>(item) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Primary failed, try failover
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> q.<span style="color:#900;font-weight:bold">tryFailover</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Retry with backup as primary
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">return</span> q.backup.<span style="color:#900;font-weight:bold">Enqueue</span>(item)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">tryFailover</span>() <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Only one goroutine should perform failover
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> !q.isHealthy.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(<span style="color:#000;font-weight:bold">true</span>, <span style="color:#000;font-weight:bold">false</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Record failover metrics
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    q.stats.failoverCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    q.stats.lastFailover.<span style="color:#900;font-weight:bold">Store</span>(time.<span style="color:#900;font-weight:bold">Now</span>().<span style="color:#900;font-weight:bold">UnixNano</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Swap primary and backup
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    temp <span style="color:#000;font-weight:bold">:=</span> q.primary
</span></span><span style="display:flex;"><span>    q.primary = q.backup
</span></span><span style="display:flex;"><span>    q.backup = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Mark system as healthy again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    q.isHealthy.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Imagine you&rsquo;re standing at the edge of a technological frontier. Lock-free programming is evolving rapidly, just like how cars evolved from Model T&rsquo;s to Teslas. Let&rsquo;s explore what&rsquo;s on the horizon!</p>
<h2 id="emerging-patterns-the-new-wave">Emerging Patterns: The New Wave</h2>
<p>Think of these patterns like cooking techniques that are gaining popularity in modern kitchens:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// The future of shared memory: Memory Pools
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> ZeroAllocationQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    pool  <span style="color:#000;font-weight:bold">*</span>LockFreePool[Node]
</span></span><span style="display:flex;"><span>    head  atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>    tail  atomic.Pointer[Node]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ZeroAllocationQueue) <span style="color:#900;font-weight:bold">Enqueue</span>(value <span style="color:#000;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Get a pre-allocated node from the pool
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    node <span style="color:#000;font-weight:bold">:=</span> q.pool.<span style="color:#900;font-weight:bold">Acquire</span>()
</span></span><span style="display:flex;"><span>    node.value = value
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>        tail <span style="color:#000;font-weight:bold">:=</span> q.tail.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> q.tail.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(tail, node) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Someone else won - return node to pool
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        q.pool.<span style="color:#900;font-weight:bold">Release</span>(node)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is like having a magical kitchen where utensils clean and store themselves automatically!</p>
<h2 id="hardware-trends-the-new-kitchen-appliances">Hardware Trends: The New Kitchen Appliances</h2>
<p>Modern CPUs are introducing new instructions that make lock-free programming easier:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Future hardware might support these directly
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> WaitFreeRegister[T any] <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value atomic.Pointer[T]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (r <span style="color:#000;font-weight:bold">*</span>WaitFreeRegister[T]) <span style="color:#900;font-weight:bold">WriteWithoutContention</span>(new T) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Imaginary future CPU instruction
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// that guarantees no contention
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">atomicWriteNoContention</span>(<span style="color:#000;font-weight:bold">&amp;</span>r.value, new)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s like getting a new kitchen appliance that makes previously complex tasks simple!</p>
<h2 id="new-atomic-primitives-better-building-blocks">New Atomic Primitives: Better Building Blocks</h2>
<p>The future might bring us more powerful atomic operations:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Hypothetical future atomic operations
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> FutureAtomics <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Atomic fetch-and-multiply
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    FetchAndMul <span style="color:#000;font-weight:bold">func</span>(addr <span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">uint64</span>, val <span style="color:#458;font-weight:bold">uint64</span>) <span style="color:#458;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Atomic conditional update
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    UpdateIf <span style="color:#000;font-weight:bold">func</span>(addr <span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">uint64</span>, update <span style="color:#000;font-weight:bold">func</span>(old <span style="color:#458;font-weight:bold">uint64</span>) (new <span style="color:#458;font-weight:bold">uint64</span>, ok <span style="color:#458;font-weight:bold">bool</span>)) <span style="color:#458;font-weight:bold">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Using these new primitives
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> SmartCounter <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    value atomic.Uint64
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (c <span style="color:#000;font-weight:bold">*</span>SmartCounter) <span style="color:#900;font-weight:bold">MultiplyIfEven</span>(factor <span style="color:#458;font-weight:bold">uint64</span>) <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> atomic.<span style="color:#900;font-weight:bold">UpdateIf</span>(<span style="color:#000;font-weight:bold">&amp;</span>c.value, <span style="color:#000;font-weight:bold">func</span>(old <span style="color:#458;font-weight:bold">uint64</span>) (<span style="color:#458;font-weight:bold">uint64</span>, <span style="color:#458;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> old<span style="color:#000;font-weight:bold">%</span><span style="color:#099">2</span> <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> old <span style="color:#000;font-weight:bold">*</span> factor, <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> old, <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="research-directions-the-laboratory">Research Directions: The Laboratory</h2>
<p>Researchers are exploring fascinating new territories:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Experimental: Self-adjusting data structures
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> AdaptiveLockFreeQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    queues      []<span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    contention  atomic.Uint64
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Automatically adjusts based on contention
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>AdaptiveLockFreeQueue) <span style="color:#900;font-weight:bold">adjust</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> q.contention.<span style="color:#900;font-weight:bold">Load</span>() &gt; threshold {
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// Split into multiple queues
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            q.<span style="color:#900;font-weight:bold">split</span>()
</span></span><span style="display:flex;"><span>        } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic">// Merge queues
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>            q.<span style="color:#900;font-weight:bold">merge</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Experimental: Quantum-resistant lock-free algorithms
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> QuantumSafeRegister <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Future-proof against quantum computers
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    value atomic.Value
</span></span><span style="display:flex;"><span>    hash  atomic.Value
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-grand-vision-whats-coming-next">The Grand Vision: What&rsquo;s Coming Next?</h2>
<ol>
<li><strong>Composable Lock-Free Structures</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Future: Building complex structures from simple ones
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> ComposableLockFree[T any] <span style="color:#000;font-weight:bold">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">Atomic</span>() <span style="color:#458;font-weight:bold">bool</span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">Compose</span>(other ComposableLockFree[T]) ComposableLockFree[T]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li><strong>Self-Healing Data Structures</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> SelfHealingQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    health atomic.Value
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>SelfHealingQueue) <span style="color:#900;font-weight:bold">monitor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> q.<span style="color:#900;font-weight:bold">detect_anomaly</span>() {
</span></span><span style="display:flex;"><span>                q.<span style="color:#900;font-weight:bold">self_repair</span>()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            time.<span style="color:#900;font-weight:bold">Sleep</span>(monitorInterval)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li><strong>AI-Assisted Lock-Free Programming</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Future tools might automatically verify and optimize
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> AutoVerifiedQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// AI-verified properties
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    properties <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>        LinearizabilityVerified <span style="color:#458;font-weight:bold">bool</span>
</span></span><span style="display:flex;"><span>        WaitFreeGuaranteed     <span style="color:#458;font-weight:bold">bool</span>
</span></span><span style="display:flex;"><span>        MemorySafe             <span style="color:#458;font-weight:bold">bool</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="closing-thoughts">Closing Thoughts</h2>
<p>Lock-free programming is like space exploration – we&rsquo;ve come far, but there&rsquo;s still so much to discover. The future holds:</p>
<ul>
<li>More hardware support for atomic operations</li>
<li>Better tools for verification and testing</li>
<li>New patterns for composing lock-free structures</li>
<li>Increased focus on energy efficiency</li>
<li>Integration with emerging technologies like quantum computing</li>
</ul>
<p>The key is to stay curious and keep experimenting. As we&rsquo;ve seen throughout this journey, lock-free programming is challenging but incredibly rewarding. It&rsquo;s a field where creativity meets precision, and the possibilities are endless.</p>
<h2 id="building-a-resilient-lock-free-queue">Building a Resilient Lock-Free Queue</h2>
<p>Here&rsquo;s a complete implementation of a resilient queue that can handle failures and provides automatic failover:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;sync/atomic&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ResilientQueue implements a fault-tolerant queue with primary and backup storage
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> ResilientQueue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    primary    <span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    backup     <span style="color:#000;font-weight:bold">*</span>LockFreeQueue
</span></span><span style="display:flex;"><span>    isHealthy  atomic.Bool
</span></span><span style="display:flex;"><span>    stats      <span style="color:#000;font-weight:bold">*</span>QueueStats
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// QueueStats tracks operational metrics
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">type</span> QueueStats <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    enqueueCount   atomic.Uint64
</span></span><span style="display:flex;"><span>    dequeueCount   atomic.Uint64
</span></span><span style="display:flex;"><span>    failoverCount  atomic.Uint64
</span></span><span style="display:flex;"><span>    lastFailover   atomic.Int64
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// NewResilientQueue creates a new fault-tolerant queue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">NewResilientQueue</span>() <span style="color:#000;font-weight:bold">*</span>ResilientQueue {
</span></span><span style="display:flex;"><span>    q <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>ResilientQueue{
</span></span><span style="display:flex;"><span>        primary: <span style="color:#900;font-weight:bold">NewLockFreeQueue</span>(),
</span></span><span style="display:flex;"><span>        backup:  <span style="color:#900;font-weight:bold">NewLockFreeQueue</span>(),
</span></span><span style="display:flex;"><span>        stats:   <span style="color:#000;font-weight:bold">&amp;</span>QueueStats{},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    q.isHealthy.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> q
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> (
</span></span><span style="display:flex;"><span>    ErrQueueFull      = errors.<span style="color:#900;font-weight:bold">New</span>(<span style="color:#d14">&#34;queue is full&#34;</span>)
</span></span><span style="display:flex;"><span>    ErrQueueEmpty     = errors.<span style="color:#900;font-weight:bold">New</span>(<span style="color:#d14">&#34;queue is empty&#34;</span>)
</span></span><span style="display:flex;"><span>    ErrSystemUnhealthy = errors.<span style="color:#900;font-weight:bold">New</span>(<span style="color:#d14">&#34;system is in unhealthy state&#34;</span>)
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Enqueue adds an item to the queue with automatic failover
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">Enqueue</span>(item <span style="color:#000;font-weight:bold">interface</span>{}) <span style="color:#458;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> !q.isHealthy.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ErrSystemUnhealthy
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Try primary queue first
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> q.primary.<span style="color:#900;font-weight:bold">Enqueue</span>(item) {
</span></span><span style="display:flex;"><span>        q.stats.enqueueCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Mirror to backup
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        q.backup.<span style="color:#900;font-weight:bold">Enqueue</span>(item)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Primary failed, try failover
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> q.<span style="color:#900;font-weight:bold">tryFailover</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Retry with backup as primary
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> q.backup.<span style="color:#900;font-weight:bold">Enqueue</span>(item) {
</span></span><span style="display:flex;"><span>            q.stats.enqueueCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> ErrQueueFull
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Dequeue removes and returns an item from the queue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">Dequeue</span>() (<span style="color:#000;font-weight:bold">interface</span>{}, <span style="color:#458;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> !q.isHealthy.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>, ErrSystemUnhealthy
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Try primary queue first
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> item, ok <span style="color:#000;font-weight:bold">:=</span> q.primary.<span style="color:#900;font-weight:bold">Dequeue</span>(); ok {
</span></span><span style="display:flex;"><span>        q.stats.dequeueCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Keep backup in sync
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        q.backup.<span style="color:#900;font-weight:bold">Dequeue</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> item, <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Primary failed, try failover
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> q.<span style="color:#900;font-weight:bold">tryFailover</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Retry with backup as primary
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> item, ok <span style="color:#000;font-weight:bold">:=</span> q.backup.<span style="color:#900;font-weight:bold">Dequeue</span>(); ok {
</span></span><span style="display:flex;"><span>            q.stats.dequeueCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> item, <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>, ErrQueueEmpty
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// tryFailover attempts to switch to backup queue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">tryFailover</span>() <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Only one goroutine should perform failover
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> !q.isHealthy.<span style="color:#900;font-weight:bold">CompareAndSwap</span>(<span style="color:#000;font-weight:bold">true</span>, <span style="color:#000;font-weight:bold">false</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Record failover metrics
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    q.stats.failoverCount.<span style="color:#900;font-weight:bold">Add</span>(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    q.stats.lastFailover.<span style="color:#900;font-weight:bold">Store</span>(time.<span style="color:#900;font-weight:bold">Now</span>().<span style="color:#900;font-weight:bold">UnixNano</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Swap primary and backup
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    temp <span style="color:#000;font-weight:bold">:=</span> q.primary
</span></span><span style="display:flex;"><span>    q.primary = q.backup
</span></span><span style="display:flex;"><span>    q.backup = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Mark system as healthy again
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    q.isHealthy.<span style="color:#900;font-weight:bold">Store</span>(<span style="color:#000;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// GetStats returns current queue statistics
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">GetStats</span>() QueueStats {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> QueueStats{
</span></span><span style="display:flex;"><span>        enqueueCount:  q.stats.enqueueCount.<span style="color:#900;font-weight:bold">Load</span>(),
</span></span><span style="display:flex;"><span>        dequeueCount:  q.stats.dequeueCount.<span style="color:#900;font-weight:bold">Load</span>(),
</span></span><span style="display:flex;"><span>        failoverCount: q.stats.failoverCount.<span style="color:#900;font-weight:bold">Load</span>(),
</span></span><span style="display:flex;"><span>        lastFailover:  q.stats.lastFailover.<span style="color:#900;font-weight:bold">Load</span>(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// IsHealthy returns the current health status
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">IsHealthy</span>() <span style="color:#458;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> q.isHealthy.<span style="color:#900;font-weight:bold">Load</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Size returns the number of items in the primary queue
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> (q <span style="color:#000;font-weight:bold">*</span>ResilientQueue) <span style="color:#900;font-weight:bold">Size</span>() <span style="color:#458;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> q.isHealthy.<span style="color:#900;font-weight:bold">Load</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> q.primary.<span style="color:#900;font-weight:bold">Size</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> q.backup.<span style="color:#900;font-weight:bold">Size</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This implementation provides several important features:</p>
<ol>
<li><strong>Automatic Failover</strong>: Seamlessly switches to backup queue if primary fails</li>
<li><strong>Data Consistency</strong>: Maintains consistency between primary and backup queues</li>
<li><strong>Health Monitoring</strong>: Tracks system health and operation statistics</li>
<li><strong>Thread Safety</strong>: All operations are lock-free and thread-safe</li>
<li><strong>Error Handling</strong>: Proper error handling for all edge cases</li>
<li><strong>Metrics</strong>: Comprehensive statistics for monitoring and debugging</li>
</ol>
<p>The <code>ResilientQueue</code> can be used in high-availability systems where data loss is not acceptable. It automatically handles failures and provides monitoring capabilities through its stats interface.</p>


<div class="mt-6 py-6 border-gray-200 border-t flex justify-between">
    
    <a href="/go/concurrency-and-worker-pools/" class="pr-4">&larr; The Evolution of Concurrency Patterns in Go: From Goroutines to Advanced Worker Pools</a>
    
        
</div>



    </article>
    </div>
    <footer class="container mx-auto pl-5 pt-3 pb-5 mt-32 border-t border-gray-400">
        <div class="text-xs text-gray-700 float-right h-24">
            &copy; 2025 Prasanth Janardhanan
        </div>
    </footer>
</body>
</html>

